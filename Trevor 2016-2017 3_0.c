#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    powerExpander,  sensorAnalog)
#pragma config(Sensor, in2,    clawPosition,   sensorPotentiometer)
#pragma config(Sensor, dgtl9,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl11, rightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           backRight,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port2,           frontLeft,     tmotorVex393, openLoop)
#pragma config(Motor,  port3,           clawLeft,      tmotorVex393, openLoop)
#pragma config(Motor,  port4,           armLeft,       tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           liftLeft,      tmotorVex393, openLoop)
#pragma config(Motor,  port6,           liftRight,     tmotorVex393, openLoop)
#pragma config(Motor,  port7,           armRight,      tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           clawRight,     tmotorVex393, openLoop)
#pragma config(Motor,  port9,           frontRight,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port10,          backLeft,      tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
//#include "C:\Users\7157R\Desktop\Robot Includes\SongsCore.c"
//#include "C:\Users\7157R\Desktop\Robot Includes\UndertaleSongs.c"

long LCD_autonomousTestTimer = 0;
bool g_autonomousTrialRun = false;
int LCD_refreshCounter = 0; //tick counter for refreshing the battery values on the LCD panel
int LCD_holdTime = 0; //counter used for activating the menu
int LCD_menuOption = 0; //signifies the prgram selected in the menu
long LCD_timeforDriver = 0; //if trial run is true, this is how long in milliseconds it will be
bool LCD_trialRun = false; //used to tell when a time trial for driver control is happening
bool LCD_menuMode = false; //when true, the menu shows up on the LCD panel
bool LCD_lockMenuChanger = false; //prevents the menu options from cycling through really fast
bool LCD_selectProgram = false; //the selected program will activate if true
bool g_autonomousDecision = false;

void LCD_stopAllMotors()
{
	motor[port1] = 0;
	motor[port2] = 0;
	motor[port3] = 0;
	motor[port4] = 0;
	motor[port5] = 0;
	motor[port6] = 0;
	motor[port7] = 0;
	motor[port8] = 0;
	motor[port9] = 0;
	motor[port10] = 0;
}

void LCD_clear() //function for clearing both lines on the lcd panel
{
	clearLCDLine(0); //clear the top lcd panel line
	clearLCDLine(1); //clear the bottom lcd panel line
}
void LCD_updateBattery() //Displays the value of both batteries
{
	displayLCDString(0, 0, "B: "); //displays B:
	displayLCDNumber(0, 3, nImmediateBatteryLevel); //displays the primary battery
	displayLCDString(0, 7, ", "); //adds a comma and a space between the battery levels
	displayLCDNumber(0, 9, SensorValue[powerExpander]); //displays the launch battery level
	displayLCDString(0, 14, "  "); //clears the lines
}
void LCD_countdown() //used for the countdown after selecting programs on the lcd menu
{
	ClearTimer(T2); //clear the second timer
	LCD_clear(); //clear both lines of the lcd panel
	displayLCDCenteredString(0, "Start In:"); //in the center of the first line display Start In:
	int c = 0; //create a variable, c, that is used as a counter to slow down the change rate of the lcd panel
	int timeLeft = 3000; //create an integer to represent the amount of time left, starts at 3 seconds
	while(time1(T2) <= 3000) //while 3 seconds have not yet passed by
	{
		if(c >= 10) //if the counter for the value has reached 10
		{
			timeLeft = 3000 - time1(T2); //update the amount of time left
			displayLCDNumber(1, 0, timeLeft); //on the seond line display the amount of time left in the countdown
			if(timeLeft < 10) //this set of if else statements makes sure that the zeros don't stick around after the number of digits left decreases
			{
				displayLCDString(1, 1, "       ");
			}
			else if(timeLeft < 100)
			{
				displayLCDString(1, 2, "       ");
			}
			else if(timeLeft < 1000)
			{
				displayLCDString(1, 3, "       ");
			}
			c = 0; //reset c to 0
		}
		c++; //add 1 to c

	}
	LCD_clear(); //clear both lines of the lcd panel after the countdown has finished
}

float driveSpeedModifier()
{
	if(vexRT[Btn5D] == 1)
	{
		return .7;
	}
	else
	{
		return 1;
	}
}

void leftDrive(int leftDrivePower)
{
	motor[frontLeft] = driveSpeedModifier() * leftDrivePower;
	motor[backLeft] = driveSpeedModifier() * leftDrivePower;
}

void rightDrive(int rightDrivePower)
{
	motor[frontRight] = driveSpeedModifier() * rightDrivePower;
	motor[backRight] = driveSpeedModifier() * rightDrivePower;
}

void drive(int drivePower)
{
	leftDrive(drivePower);
	rightDrive(drivePower);
}

void driveControl()
{
	if(abs(vexRT[Ch3]) > 30)
	{
		leftDrive(vexRT[Ch3]);
	}
	else
	{
		leftDrive(0);
	}
	if(abs(vexRT[Ch2]) > 30)
	{
		rightDrive(vexRT[Ch2]);
	}
	else
	{
		rightDrive(0);
	}
}

void arm(int armPower)
{
	motor[armLeft] = armPower;
	motor[armRight] = armPower;
}

void lift(int liftPower)
{
	motor[liftLeft] = liftPower;
	motor[liftRight] = liftPower;
}

void armControl()
{
	if(vexRT[Btn7D] == 0)
	{
		if(vexRT[Btn6U] == 1)
		{
			arm(75);
		}
		else if(vexRT[Btn6D] == 1)
		{
			arm(-75);
		}
		else
		{
			arm(0);
		}
	}
}

void claw(int clawPower)
{
	motor[clawLeft] = clawPower;
	motor[clawRight] = clawPower;
}

void clawControl()
{
	if(vexRT[Btn7D] == 0)
	{
		if(vexRT[Btn5U] == 1)
		{
			claw(-127);
		}
		else if(vexRT[Btn5D] == 1)
		{
			claw(127);
		}
		else
		{
			claw(0);
		}
	}
	else
	{
		if(vexRT[Btn5U] == 1)
		{
			motor[clawRight] = 75;
		}
		else if(vexRT[Btn5D] == 1)
		{
			motor[clawRight] = -75;
		}
		else
		{
			motor[clawRight] = 0;
		}
		if(vexRT[Btn6U] == 1)
		{
			motor[clawLeft] = 75;
		}
		else if(vexRT[Btn6D] == 1)
		{
			motor[clawLeft] = -75;
		}
		else
		{
			motor[clawLeft] = 0;
		}
	}
}

void liftControl()
{
	if(vexRT[Btn8D] == 1)
	{
		lift(127);
	}
	else if(vexRT[Btn8U] == 1)
	{
		lift(-127);
	}
	else
	{
		lift(0);
	}
}

void userCode()
{
	driveControl();
	armControl();
	clawControl();
	liftControl();
}

#include "C:\Users\7157R\Documents\GitHub\VEX-2017-2018-7157A\Encoder Functions.c"

#include "C:\Users\7157R\Documents\GitHub\VEX-2017-2018-7157A\Autonomous Routines.c"

#include "C:\Users\7157R\Documents\GitHub\VEX-2017-2018-7157A\Autonomous Core.c"

#include "C:\Users\7157R\Documents\GitHub\VEX-2017-2018-7157A\VEX LCD Menu Core.c"

void pre_auton()
{
	//LCD_autonomousSwitcher();
	bStopTasksBetweenModes = true;
}


task autonomous()
{
	g_autonomousTrialRun = false;
	autonomousMain();
}


task usercontrol()
{
	// User control code here, inside the loop
	LCD_refreshCounter = 0; //reset the battery refresh counter
	LCD_lockMenuChanger = false; //reset this
	LCD_selectProgram = false; //reset that
	LCD_menuMode = false; //make sure the menu doesn't pop up
	bLCDBacklight = true; //turn on the LCD backlight
	LCD_trialRun = false; //do not run a trial run
	LCD_clear(); //clear both lines on the LCD panel
	LCD_holdTime = 0; //reset the counter for activating the lcd menu

	menuLCDAndMainControl(); //launch the function for the main user and LCD control
}
